<!DOCTYPE html>
<html lang="en-us">
<meta charset="UTF-8">
<title>Notre Dame Research</title>

<style>

////////////////////////////////
// HON DIAGRAM

.links line {
    stroke: #999;
    stroke-width: 2px;
}

.nodes circle {
    stroke: black;
    stroke-width: 0px;
}

////////////////////////////////
// SANKEY DIAGRAM
/*
.node rect {
	cursor: move;
	fill-opacity: .9;
	shape-rendering: crispEdges;
}

.node text {
	pointer-events: none;
	text-shadow: 0 1px 0 #fff;
}

.link {
	fill: none;
	stroke: #000;
	stroke-opacity: .2;
}

.link:hover {
	stroke-opacity: .5;
}
*/
/////////////////////////////////

</style>



<head>

<h1>The Moreau First Year Student Project</h1>

</head>



<body>

<h2>Higher Order Network Diagram</h2>
<svg id="hon_diagram" width="960" height="500"></svg>

    <div id="map"></div>
    <div id="legend">
      <h3>Change node size</h3>
      <div class="input-group" id="filters">
        <label><input type="radio" name="filter" value="all" checked="checked">  All links</label><br />
        <label><input type="radio" name="filter" value="in">  Links in</label><br />
        <label><input type="radio" name="filter" value="out">  Links out</label><br />
		<label><input type="radio" name="filter" value="none">  None (uniform size)</label><br />
      </div>
    </div>


<h2>Sankey Diagram</h2>
<svg id="sankey_diagram" width="960" height="500"></svg>


</body>

<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
//Define where to look for nodes and where to look for links
var nodepath = "nodes_classified.csv"
var linkpath = "weights-network-cell.csv"

//Load up pre-defined svg
var svg = d3.select("svg"),
	/*.call(d3.zoom().on("zoom", function () {
        svg.attr("transform", d3.event.transform)
})),*/
	width = +svg.attr("width"),
	height = +svg.attr("height");

var color = d3.scaleOrdinal(d3.schemeCategory20);

/*
// Custom implementation of a force applied to only every second node
var pickyForce = d3.forceManyBody().strength(-50);

// Save the default initialization method
var init = pickyForce.initialize; 

// Custom implementation of .initialize() calling the saved method with only
// a subset of nodes
pickyForce.initialize = function(nodes) {
    // Filter subset of nodes and delegate to saved initialization.
    init(nodes.filter(function(n) { return (+n.group != "12"); }));
    };
*/


var simulation = d3.forceSimulation()
	.force("link", d3.forceLink().id(function(d) {return d.id; })
								 .strength(link => link.value))
	.force("charge", d3.forceManyBody().strength(-10))
	//.force("picky centre", pickyForce)
	.force("collide", d3.forceCollide().radius(5))
	.force("center", d3.forceCenter(width / 2, height / 2));




//Open up node data file function(d) { console.log(d.value); return (d.value); }
d3.csv(nodepath, function(nodes_data) {
	//Create empty graph array
	graph = { "links": [] , "nodes": []};

	//Push in node data (both ID and class) from nodepath
	nodes_data.forEach(node => graph.nodes.push( { "id":node.Id , "group":node.modularity_class, "in_size":1., "out_size":1.} ) );

	//Open up the links file, and push link data in too
	d3.csv(linkpath, function(links_data) {
		links_data.forEach(link => graph.links.push( link ) );

	//Create the link and node elements visually.
 		var link = svg.append("g")
      		.attr("class", "links")
    		.selectAll("line")
    		.data(graph.links)
    		.enter().append("line")
      		.attr("stroke-opacity", function(d) { return (d.value); });

	//create a "size" argument on the graph.nodes variables
		var i;
		for (i = 0; i < graph.nodes.length; i++) {
			for (j =0; j < graph.links.length; j++) {
				if (graph.nodes[i].id === graph.links[j].source) {
					graph.nodes[i].out_size += 0.5
			}; 
				if (graph.nodes[i].id === graph.links[j].target) {
					graph.nodes[i].in_size += 0.5
			};
			};
			};

  		var node = svg.append("g")
      		.attr("class", "nodes")
    		.selectAll("circle")
    		.data(graph.nodes)
    		.enter().append("circle")
      		.attr("r",  function(d) { return d.out_size * 1; } )
      		.attr("fill", function(d) { return color(d.group); })
     		.on("mouseover", mouseOver(.2))
      		.on("mouseout", mouseOut)

      		.call(d3.drag()
          		.on("start", dragstarted)
          		.on("drag", dragged)
          		.on("end", dragended));

  node.append("title")
      .text(function(d) { return d.id; });

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//Trying to add hover network info
var linkedByIndex = {};
    graph.links.forEach(function(d) {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
    });

    // check the dictionary to see if nodes are linked
    function isConnected(a, b) {
        return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
    }

    // fade nodes on hover
    function mouseOver(opacity) {
		console.log("mouseover");
        return function(d) {
            // check all other nodes to see if they're connected
            // to this one. if so, keep the opacity at 1, otherwise
            // fade
            node.style("stroke-opacity", function(o) {
                thisOpacity = isConnected(d, o) ? 1 : opacity;
                return thisOpacity;
            });
            node.style("fill-opacity", function(o) {
                thisOpacity = isConnected(d, o) ? 1 : opacity;
                return thisOpacity;
            });
            // also style link accordingly
            link.style("stroke-opacity", function(o) {
                return o.source === d || o.target === d ? 1 : opacity;
            });
            link.style("stroke", function(o){
                return o.source === d || o.target === d ? o.source.colour : "#ddd";
            });
        };
    }

    function mouseOut() {
        node.style("stroke-opacity", 1);
        node.style("fill-opacity", 1);
        link.style("stroke-opacity", function(d) { return (d.value); });
        link.style("stroke", "#999");
    }



d3.selectAll("input[name=filter]").on("change", function(d){

  // value of selected radio
  var value = this.value;

	switch (value) {
		case "all":
			node.attr("r",  function(d) { return d.out_size + d.in_size; } )
			break;
		case "in":
			node.attr("r",  function(d) { return d.in_size; } )
			break;
		case "out":
			node.attr("r",  function(d) { return d.out_size;} )
			break;
		case "none":
			node.attr("r",  function(d) { return 5.} )
			break;
	}

/*  // those that aren't dim
  if (value !== "all"){
    value = +this.value;
    node.filter(function(d){
      return d.rating != value;
    })
    .style("opacity", "0.5");
  }*/

});



	});//close links file
});//close nodes file


function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}


</script>

<!--
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

//////////////////////////////////////////////////////////////////////
// HON DIAGRAM
//////////////////////////////////////////////////////////////////////

//Define where to look for nodes and where to look for links
var nodepath = "nodes_classified.csv"
var linkpath = "weights-network-cell.csv"

//Load up pre-defined svg
var svg = d3.select("#hon_diagram"),
	width = +svg.attr("width"),
	height = +svg.attr("height");

var color = d3.scaleOrdinal(d3.schemeCategory20);

/*
// Custom implementation of a force applied to only every second node
var pickyForce = d3.forceManyBody().strength(-50);

// Save the default initialization method
var init = pickyForce.initialize; 

// Custom implementation of .initialize() calling the saved method with only
// a subset of nodes
pickyForce.initialize = function(nodes) {
    // Filter subset of nodes and delegate to saved initialization.
    init(nodes.filter(function(n) { return (+n.group != "12"); }));
    };
*/


var simulation = d3.forceSimulation()
	.force("link", d3.forceLink().id(function(d) {return d.id; })
								 .strength(link => link.value))
	.force("charge", d3.forceManyBody().strength(-10))
	//.force("picky centre", pickyForce)
	.force("collide", d3.forceCollide().radius(6))
	.force("center", d3.forceCenter(width / 2, height / 2));


//Open up node data file function(d) { console.log(d.value); return (d.value); }
d3.csv(nodepath, function(nodes_data) {
	//Create empty graph array
	graph = { "links": [] , "nodes": []};

	//Push in node data (both ID and class) from nodepath
	nodes_data.forEach(node => graph.nodes.push( { "id":node.Id , "group":node.modularity_class} ) );

	//Open up the links file, and push link data in too
	d3.csv(linkpath, function(links_data) {
		links_data.forEach(link => graph.links.push( link ) );

 		var link = svg.append("g")
      		.attr("class", "links")
    		.selectAll("line")
    		.data(graph.links)
    		.enter().append("line")
      		.attr("stroke-opacity", function(d) { return (d.value); });

  		var node = svg.append("g")
      		.attr("class", "nodes")
    		.selectAll("circle")
    		.data(graph.nodes)
    		.enter().append("circle")
      		.attr("r", 5)
      		.attr("fill", function(d) { return color(d.group); })
     		.on("mouseover", mouseOver(.2))
      		.on("mouseout", mouseOut)

      		.call(d3.drag()
          		.on("start", dragstarted)
          		.on("drag", dragged)
          		.on("end", dragended));

  node.append("title")
      .text(function(d) { return d.id; });

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
//Trying to add hover network info
var linkedByIndex = {};
    graph.links.forEach(function(d) {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
    });

    // check the dictionary to see if nodes are linked
    function isConnected(a, b) {
        return linkedByIndex[a.index + "," + b.index] || linkedByIndex[b.index + "," + a.index] || a.index == b.index;
    }

    // fade nodes on hover
    function mouseOver(opacity) {
		console.log("mouseover");
        return function(d) {
            // check all other nodes to see if they're connected
            // to this one. if so, keep the opacity at 1, otherwise
            // fade
            node.style("stroke-opacity", function(o) {
                thisOpacity = isConnected(d, o) ? 1 : opacity;
                return thisOpacity;
            });
            node.style("fill-opacity", function(o) {
                thisOpacity = isConnected(d, o) ? 1 : opacity;
                return thisOpacity;
            });
            // also style link accordingly
            link.style("stroke-opacity", function(o) {
                return o.source === d || o.target === d ? 1 : opacity;
            });
            link.style("stroke", function(o){
                return o.source === d || o.target === d ? o.source.colour : "#ddd";
            });
        };
    }

    function mouseOut() {
        node.style("stroke-opacity", 1);
        node.style("fill-opacity", 1);
        link.style("stroke-opacity", function(d) { return (d.value); });
        link.style("stroke", "#999");
    }



	});//close links file
});//close nodes file


function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

</script>
-->

<!--
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="sankey.js"></script>
<script>

//////////////////////////////////////////////////////////////////////
// SANKEY DIAGRAM
//////////////////////////////////////////////////////////////////////

const FILENAME = "sample.csv";

var units = "Widgets";

var margin = {top: 10, right: 10, bottom: 10, left: 10},
	width = 700 - margin.left - margin.right,
	height = 300 - margin.top - margin.bottom;

var formatNumber = d3.format(",.0f"),    // zero decimal places
	format = function(d) { return formatNumber(d) + " " + units; },
	color = d3.scale.category20();

// append the svg canvas to the page
var svg = d3.select("#sankey_diagram")
.attr("width", width + margin.left + margin.right)
.attr("height", height + margin.top + margin.bottom)
.append("g")
.attr("transform", 
				"translate(" + margin.left + "," + margin.top + ")");

// Set the sankey diagram properties
var sankey = d3.sankey()
	.nodeWidth(36)
	.nodePadding(40)
	.size([width, height]);

var path = sankey.link();

// load the data (using the timelyportfolio csv method)
d3.csv(FILENAME, function(error, data) {

	//set up graph in same style as original example but empty
	graph = {"nodes" : [], "links" : []};

		data.forEach(function (d) {
			graph.nodes.push({ "name": d.source });
			graph.nodes.push({ "name": d.target });
			graph.links.push({ "source": d.source,
								"target": d.target,
								"value": +d.value });
		});

		// return only the distinct / unique nodes
		graph.nodes = d3.keys(d3.nest()
			.key(function (d) { return d.name; })
			.map(graph.nodes));

		// loop through each link replacing the text with its index from node
		graph.links.forEach(function (d, i) {
			graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
			graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
		});

		//now loop through each nodes to make nodes an array of objects
		// rather than an array of strings
		graph.nodes.forEach(function (d, i) {
			graph.nodes[i] = { "name": d };
		});

		sankey
			.nodes(graph.nodes)
			.links(graph.links)
			.layout(32);

		// add in the links
		var link = svg.append("g").selectAll(".link")
			.data(graph.links)
			.enter().append("path")
			.attr("class", "link")
			.attr("d", path)
			.style("stroke-width", function(d) { return Math.max(1, d.dy); })
			.sort(function(a, b) { return b.dy - a.dy; });

		// add the link titles
		link.append("title")
			.text(function(d) {
				return d.source.name + " → " + 
						d.target.name + "\n" + format(d.value); });

		// add in the nodes
		var node = svg.append("g").selectAll(".node")
			.data(graph.nodes)
			.enter().append("g")
			.attr("class", "node")
			.attr("transform", function(d) { 
				return "translate(" + d.x + "," + d.y + ")"; })
			.call(d3.behavior.drag()
			.origin(function(d) { return d; })
			.on("dragstart", function() { 
				this.parentNode.appendChild(this); })
			.on("drag", dragmove));

		// add the rectangles for the nodes
		node.append("rect")
			.attr("height", function(d) { return d.dy; })
			.attr("width", sankey.nodeWidth())
			.style("fill", function(d) { 
				return d.color = color(d.name.replace(/ .*/, "")); })
			.style("stroke", function(d) { 
				return d3.rgb(d.color).darker(2); })
			.append("title")
			.text(function(d) { 
				return d.name + "\n" + format(d.value); });

		// add in the title for the nodes
		node.append("text")
			.attr("x", -6)
			.attr("y", function(d) { return d.dy / 2; })
			.attr("dy", ".35em")
			.attr("text-anchor", "end")
			.attr("transform", null)
			.text(function(d) { return d.name; })
			.filter(function(d) { return d.x < width / 2; })
			.attr("x", 6 + sankey.nodeWidth())
			.attr("text-anchor", "start");

		// the function for moving the nodes
		function dragmove(d) {
			d3.select(this).attr("transform", 
				"translate(" + d.x + "," + (
			d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
				) + ")");
			sankey.relayout();
			link.attr("d", path);
		}

});

</script>

-->


<html>
